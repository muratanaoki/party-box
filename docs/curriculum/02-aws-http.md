# HTTP と HTTPS の仕組み

[← 目次に戻る](./02-aws.md)

---

## この章で学ぶこと

- HTTP の基本的な仕組み
- HTTPS と暗号化
- SSL 証明書の仕組み
- AWS での証明書管理

---

## 目次

1. [HTTP とは](#http-とは)
2. [HTTP のリクエストとレスポンス](#http-のリクエストとレスポンス)
3. [HTTPS とは](#https-とは)
4. [暗号化の基礎知識](#暗号化の基礎知識)
5. [SSL 証明書とは](#ssl-証明書とは)
6. [HTTPS 通信の流れ](#https-通信の流れ)
7. [HTTPS の導入方法](#https-の導入方法)
8. [まとめ](#まとめ)
9. [確認問題](#確認問題)

---

## HTTP とは

**HTTP = HyperText Transfer Protocol**

Web ブラウザとサーバーが通信するための「約束事（プロトコル）」。

```mermaid
sequenceDiagram
    participant B as ブラウザ
    participant S as サーバー

    B->>S: リクエスト（このページください）
    S->>B: レスポンス（はい、どうぞ）
```

- ブラウザが「リクエスト」を送り、サーバーが「レスポンス」を返す
- この繰り返しで Web が動いている

---

## HTTP のリクエストとレスポンス

### リクエストの構造

```http
GET /api/users HTTP/1.1
Host: example.com
User-Agent: Mozilla/5.0 ...
Accept: application/json
Authorization: Bearer eyJhbGciOiJIUzI1NiIs...
```

| 部分         | 説明           | 例                            |
| ------------ | -------------- | ----------------------------- |
| **メソッド** | 何をしたいか   | `GET`（取得）、`POST`（作成） |
| **パス**     | どのリソースか | `/api/users`                  |
| **ヘッダー** | 追加情報       | 認証、形式指定など            |
| **ボディ**   | 送信データ     | POST の時のデータ             |

### HTTP メソッド

| メソッド   | 用途               | 例                     |
| ---------- | ------------------ | ---------------------- |
| **GET**    | データ取得         | ユーザー一覧を取得     |
| **POST**   | データ作成         | 新しいユーザーを登録   |
| **PUT**    | データ更新（全体） | ユーザー情報を全て更新 |
| **PATCH**  | データ更新（部分） | 名前だけ更新           |
| **DELETE** | データ削除         | ユーザーを削除         |

### レスポンスの構造

```http
HTTP/1.1 200 OK
Content-Type: application/json
Content-Length: 123

{"users": [{"id": 1, "name": "田中"}]}
```

| 部分                 | 説明               |
| -------------------- | ------------------ |
| **ステータスコード** | 結果（200 = 成功） |
| **ヘッダー**         | メタ情報           |
| **ボディ**           | 実際のデータ       |

### ステータスコード

| コード  | 意味                  | よくある状況                   |
| ------- | --------------------- | ------------------------------ |
| **200** | OK                    | 正常終了                       |
| **201** | Created               | POST で作成成功                |
| **301** | Moved Permanently     | URL が変わった（リダイレクト） |
| **400** | Bad Request           | リクエストがおかしい           |
| **401** | Unauthorized          | 認証が必要                     |
| **403** | Forbidden             | 権限がない                     |
| **404** | Not Found             | ページが見つからない           |
| **500** | Internal Server Error | サーバーでエラー               |

**覚え方:** `2xx` = 成功、`3xx` = リダイレクト、`4xx` = クライアントのミス、`5xx` = サーバーのミス

---

## HTTPS とは

**HTTPS = HTTP + Secure（暗号化）**

### HTTP の問題

HTTP は**平文（暗号化なし）** で通信するため、盗聴される危険がある。

```mermaid
flowchart LR
    subgraph HTTP["HTTP（危険）"]
        U1["ユーザー"] -->|パスワード: password123| A1["盗聴者"]
        A1 -->|丸見え！| S1["サーバー"]
    end
```

### HTTPS で解決

```mermaid
flowchart LR
    subgraph HTTPS["HTTPS（安全）"]
        U2["ユーザー"] -->|x8Kj2#mP9...| A2["盗聴者"]
        A2 -->|意味不明...| S2["サーバー"]
    end
```

暗号化されているので、盗聴されても解読できない。

### SSL/TLS とは

**SSL/TLS = HTTPS の「S」を実現するプロトコル**

HTTP 通信を暗号化するための仕組み。以下の 3 つを行う：

| 役割 | 説明 |
|------|------|
| **暗号化** | 通信内容を暗号化して盗聴を防ぐ |
| **認証** | 証明書でサーバーが本物か確認する |
| **完全性** | データが改ざんされていないか検証する |

```mermaid
flowchart LR
    subgraph HTTPS["HTTPS"]
        HTTP["HTTP"] --> TLS["SSL/TLS で暗号化"]
    end
```

つまり **HTTPS = HTTP + SSL/TLS**。

### SSL と TLS の違い

「SSL証明書」「TLSハンドシェイク」など、SSL と TLS という言葉が混在している。

| 項目 | SSL | TLS |
|------|-----|-----|
| 正式名称 | Secure Sockets Layer | Transport Layer Security |
| 関係 | 古い | SSL の後継（新しい） |
| 現在 | **全バージョン廃止** | 現役（1.2, 1.3） |

**歴史:**

```
SSL 1.0 → 公開されず（脆弱性）
SSL 2.0 → 1995年（廃止）
SSL 3.0 → 1996年（廃止）
    ↓ 名前が変わった
TLS 1.0 → 1999年（非推奨）
TLS 1.1 → 2006年（非推奨）
TLS 1.2 → 2008年（現役）
TLS 1.3 → 2018年（現役・最新）
```

**要するに:** 今使われているのは全部 TLS。SSL は死んでいる。

ただし「SSL証明書」「SSL終端」のように **SSL という言葉が慣習的に残っている**。

| よく使う言葉 | 実際は |
|-------------|--------|
| SSL証明書 | TLS で使う証明書 |
| SSL終端 | TLS 終端 |
| HTTPS | HTTP over TLS |

---

## 暗号化の基礎知識

HTTPS では 2 種類の暗号化方式を組み合わせて使う。

### 共通鍵暗号（対称暗号）

**同じ鍵** で暗号化と復号化を行う。

```mermaid
flowchart LR
    P1["平文"] -->|鍵Aで暗号化| C["暗号文"] -->|鍵Aで復号化| P2["平文"]
```

| メリット | デメリット               |
| -------- | ------------------------ |
| 高速     | 鍵を安全に渡す方法がない |

### 公開鍵暗号（非対称暗号）

**2 つの鍵**（公開鍵と秘密鍵）をペアで使う。

```
┌─────────────────────────────────────────┐
│  鍵ペアを生成（数学的に関連している）     │
│                                         │
│  秘密鍵: 自分だけが持つ（絶対に渡さない） │
│  公開鍵: 誰に渡してもOK（公開する）       │
└─────────────────────────────────────────┘
```

**重要な性質:**

| 暗号化に使う鍵 | 復号できる鍵 |
|---------------|-------------|
| 公開鍵 | 秘密鍵だけ |
| 秘密鍵 | 公開鍵だけ |

この性質を使って **2つのこと** ができる。

#### 使い方1: 暗号化（秘密を送る）

「他人に秘密のメッセージを送りたい」時に使う。

```mermaid
flowchart LR
    A["Aさん"] -->|Bの公開鍵で暗号化| Msg["暗号文"]
    Msg -->|Bの秘密鍵で復号| B["Bさん"]
```

```
1. Bさんが公開鍵を公開している
2. Aさんは「Bの公開鍵」でメッセージを暗号化して送る
3. Bさんは「Bの秘密鍵」で復号

→ Bの秘密鍵を持ってるのはBだけ → Bしか読めない
```

#### 使い方2: 署名（本人証明）

「これは確かに俺が書いた」と証明したい時に使う。

```mermaid
flowchart LR
    B["Bさん"] -->|Bの秘密鍵で署名| Msg["署名付きメッセージ"]
    Msg -->|Bの公開鍵で検証| A["誰でも検証できる"]
```

```
1. Bさんは「Bの秘密鍵」でメッセージに署名
2. 誰でも「Bの公開鍵」で検証できる
3. 検証OK = Bの秘密鍵で作られた = Bが書いた証拠

→ Bの秘密鍵を持ってるのはBだけ → Bしか作れない
```

| メリット             | デメリット                       |
| -------------------- | -------------------------------- |
| 鍵を安全に交換できる | 低速（共通鍵の 100-1000 倍遅い） |

### HTTPS では両方使う

1. **公開鍵暗号** で共通鍵を安全に交換
2. **共通鍵暗号** で実際のデータを暗号化

→ セキュリティと速度を両立

---

## SSL 証明書とは

### なぜ証明書が必要？

暗号化だけでは不十分。**相手が本物か確認する必要がある。**

```mermaid
sequenceDiagram
    participant U as ユーザー
    participant A as 攻撃者（偽サイト）
    participant R as 本物のサイト

    U->>A: サイトにアクセス（と思ってる）
    Note over A: 攻撃者が間に入る
    A->>R: 本物に中継
    R->>A: 本物の応答
    A->>U: 改ざんして返す
    Note over U: 情報を入力してしまう
```

証明書があると、ブラウザが「このサイトは本物じゃない」と警告してくれる。

### 証明書の役割

| 役割             | 説明                             |
| ---------------- | -------------------------------- |
| **身元証明**     | このサイトは本物ですよ           |
| **公開鍵の配布** | 暗号化に使う公開鍵を安全に渡す   |
| **改ざん検知**   | 証明書が改ざんされていないか保証 |

### 証明書の中身

```
┌─────────────────────────────────────┐
│         SSL 証明書                   │
├─────────────────────────────────────┤
│ 発行先: example.com                  │  ← このドメイン用
│ 発行者: DigiCert Inc                 │  ← 認証局（CA）
│ 有効期限: 2024/01/01 - 2025/01/01   │
│ 公開鍵: MIIBIjANBgkqhkiG9w0B...     │  ← 暗号化に使う
│ 署名: SHA256withRSA...              │  ← CA の署名
└─────────────────────────────────────┘
```

### 認証局（CA）とは

**CA = Certificate Authority（認証局）**

「この証明書は本物ですよ」と保証する **信頼された第三者機関**。

```mermaid
flowchart LR
    Owner["サイト運営者"] -->|1. 申請| CA["認証局"]
    CA -->|2. 本人確認| Owner
    CA -->|3. 署名付き証明書を発行| Owner
    Owner -->|4. サーバーに設置| Server["サーバー"]
```

**主な認証局:**

| 認証局            | 特徴                         |
| ----------------- | ---------------------------- |
| **Let's Encrypt** | 無料、自動更新、広く使われる |
| **DigiCert**      | 大企業向け、高信頼           |
| **AWS ACM**       | AWS 専用、無料               |

### なぜ CA を信頼できる？

ブラウザ/OS に「信頼する CA リスト（ルート証明書）」が内蔵されているから。

- **CA の証明書** → ブラウザ/OS にプリインストール（約 100〜150 個）
- **各サイトの証明書** → サーバーからその都度送られてくる

CA が署名しているので、CA さえ信頼できれば全てのサイトを検証できる。

### デジタル署名の仕組み

証明書の「署名」で、どうやって本物か確認できるのか。

#### サーバーから届くもの

Amazon にアクセスすると、サーバーから **証明書** が届く。

```
┌─────────────────────────────────────────┐
│         Amazon の証明書                  │
├─────────────────────────────────────────┤
│ 【内容部分】                             │
│   発行先: amazon.co.jp                   │
│   発行者: DigiCert                       │
│   公開鍵: XXXXXX...                      │
│   有効期限: 2025/01/01                   │
├─────────────────────────────────────────┤
│ 【署名部分】                             │
│   xyz789ghi012...                        │
│   （CAが秘密鍵で暗号化したハッシュ値）    │
└─────────────────────────────────────────┘
```

証明書 = **内容** + **署名** がセットで届く。

#### 署名はどうやって作られた？

CA（DigiCert）が証明書を発行した時：

```
1. 証明書の内容をハッシュ化
   「発行先: amazon.co.jp, 公開鍵: XXX, ...」
       ↓ ハッシュ関数（SHA-256）
   ハッシュ値: abc123

2. ハッシュ値を CA の秘密鍵で暗号化
   abc123
       ↓ DigiCert の秘密鍵で暗号化
   署名: xyz789
```

#### ブラウザはどうやって検証する？

**2つのハッシュ値を比較する。**

```
┌─────────────────────────────────────────────────────┐
│ 【ハッシュ値A】署名から取り出す                       │
│                                                     │
│   署名 xyz789                                       │
│       ↓ DigiCert の公開鍵で復号                     │
│   ハッシュ値A: abc123                               │
└─────────────────────────────────────────────────────┘

┌─────────────────────────────────────────────────────┐
│ 【ハッシュ値B】自分で計算する                         │
│                                                     │
│   証明書の内容（発行先、公開鍵、有効期限...）         │
│       ↓ 自分でハッシュ化                            │
│   ハッシュ値B: abc123                               │
└─────────────────────────────────────────────────────┘

A == B ? → 一致！ → 本物だ！
```

```mermaid
flowchart TB
    subgraph Compare["比較するもの"]
        Sig["署名 xyz789"] -->|CAの公開鍵で復号| HashA["ハッシュ値A: abc123"]
        Cert["証明書の内容"] -->|自分でハッシュ化| HashB["ハッシュ値B: abc123"]
    end

    HashA --> Check["A == B ?"]
    HashB --> Check
    Check -->|一致| OK["本物！"]
    Check -->|不一致| NG["偽物！"]
```

**何を確認しているか:**
- 「CA が署名した時の内容」と「今届いた内容」が同じか
- 一致 = CA が署名してから改ざんされていない = 本物

#### なぜ偽造できない？

攻撃者が偽の amazon.co.jp 証明書を作ろうとすると：

```
1. 攻撃者が偽の証明書を作る
   「発行先: amazon.co.jp, 公開鍵: 攻撃者のやつ」

2. 署名を作りたい
   内容をハッシュ化 → def456
   def456 を暗号化したい... でも DigiCert の秘密鍵がない！

3. 仕方なく適当な署名を作る → zzz999

4. ブラウザで検証される
   署名 zzz999 を DigiCert の公開鍵で復号 → ???（でたらめな値）
   証明書の内容をハッシュ化 → def456

   ??? != def456 → 一致しない！ → 偽物だとバレる
```

**ポイント:**
- CA の秘密鍵を持っているのは CA だけ
- 正しい署名を作れるのは CA だけ
- **秘密鍵がなければ、正しい署名は絶対に作れない**

### 証明書チェーン（信頼の連鎖）

```mermaid
flowchart TB
    Root["ルート証明書<br/>（ブラウザに内蔵）"]
    Inter["中間証明書<br/>（CA が発行）"]
    Leaf["サーバー証明書<br/>（サイト用）"]

    Root -->|署名| Inter -->|署名| Leaf

    style Root fill:#4caf50,color:#fff
    style Inter fill:#2196f3,color:#fff
    style Leaf fill:#ff9800
```

| 証明書             | 説明                                      |
| ------------------ | ----------------------------------------- |
| **ルート証明書**   | 最上位の CA。ブラウザに最初から入っている |
| **中間証明書**     | ルート CA が発行。日常的な発行を担当      |
| **サーバー証明書** | 実際のサイト用。中間 CA が発行            |

### なぜ中間 CA が必要？（セキュリティ上の理由）

「ルート CA が直接発行すればいいじゃん」と思うかもしれないが、**超重要なセキュリティ上の理由** がある。

#### ルート CA の秘密鍵は最重要資産

```
もしルートCAの秘密鍵が漏洩したら...

┌─────────────────────────────────────────────────────┐
│ DigiCert ルートCA の秘密鍵が盗まれた！               │
│                                                     │
│ → このルートCAが署名した全ての証明書が危険に        │
│ → 何百万ものサイトが影響を受ける                    │
│ → ブラウザからこのルートCAを削除するしかない        │
│ → 大規模なインターネット障害                        │
└─────────────────────────────────────────────────────┘
```

**ルート CA の秘密鍵は、その CA の信頼の根幹。** これが漏れたら全てが終わり。

#### だから中間 CA に任せる

```
┌─────────────────────────────────────────────────────┐
│ ルート CA の秘密鍵                                   │
│   → オフラインの金庫で厳重に保管                     │
│   → ほとんど使わない（中間証明書の発行時のみ）       │
│   → 使う頻度が低い = 漏洩リスクが低い                │
├─────────────────────────────────────────────────────┤
│ 中間 CA の秘密鍵                                     │
│   → オンラインで日常的に使用                         │
│   → サーバー証明書を毎日たくさん発行                 │
│   → 使う頻度が高い = 漏洩リスクがある                │
└─────────────────────────────────────────────────────┘
```

#### もし中間 CA が漏洩しても...

```
中間CAの秘密鍵が漏洩した場合

┌─────────────────────────────────────────────────────┐
│ DigiCert 中間CA-A の秘密鍵が盗まれた！               │
│                                                     │
│ → その中間CAが発行した証明書だけが危険              │
│ → 中間CA-A の証明書を「失効」させる                  │
│ → ルートCAは無事 → 他の中間CAは影響なし             │
│ → 被害を最小限に抑えられる                          │
└─────────────────────────────────────────────────────┘
```

**会社に例えると:**

```
┌─────────────────────────────────────────────────────┐
│ ルートCA = 社長                                      │
│   → 最終決定権を持つが、普段は表に出ない            │
│   → 契約書への署名は部長に任せる                    │
│                                                     │
│ 中間CA = 部長                                        │
│   → 日常業務の契約書に署名する                      │
│   → もし部長が不正をしたら → クビにして交代         │
│   → 社長（ルート）は無傷、会社は存続                │
│                                                     │
│ もし社長が直接全部やっていたら...                   │
│   → 社長が問題起こしたら会社終了                    │
└─────────────────────────────────────────────────────┘
```

**まとめ:**

| 観点 | ルートCA直接発行 | 中間CAを挟む |
|------|-----------------|-------------|
| 秘密鍵の使用頻度 | 毎日大量に使う | ほぼ使わない（オフライン） |
| 漏洩リスク | 高い | 低い |
| 漏洩時の被害 | 全滅 | 一部のみ（失効で対応可） |
| 復旧 | 不可能に近い | 中間CAを交換すればOK |

→ **リスク分散のために階層構造にしている**

### チェーンをたどる検証の流れ

Amazon にアクセスした時、ブラウザは何をしているか。

#### Step 1: 証明書を受け取る

サーバーから **2つの証明書** が届く。

```
┌─────────────────────────────────────────────────────┐
│ 【サーバー証明書】amazon.co.jp 用                    │
├─────────────────────────────────────────────────────┤
│ 内容:                                               │
│   発行先: amazon.co.jp                              │
│   発行者: DigiCert 中間CA                           │
│   公開鍵: XXXX...                                   │
│ 署名: aaaa...（DigiCert 中間CA の秘密鍵で作成）      │
└─────────────────────────────────────────────────────┘

┌─────────────────────────────────────────────────────┐
│ 【中間証明書】DigiCert 中間CA 用                     │
├─────────────────────────────────────────────────────┤
│ 内容:                                               │
│   発行先: DigiCert 中間CA                           │
│   発行者: DigiCert ルートCA                         │
│   公開鍵: YYYY...                                   │
│ 署名: bbbb...（DigiCert ルートCA の秘密鍵で作成）    │
└─────────────────────────────────────────────────────┘
```

#### Step 2: サーバー証明書を検証

**「サーバー証明書」が本物か確認する。**

```
サーバー証明書を見る
    ↓
「発行者: DigiCert 中間CA」と書いてある
    ↓
DigiCert 中間CA の公開鍵を使って署名を検証する
```

**署名の検証（さっき説明したやつ）:**

```
┌─────────────────────────────────────────────────────┐
│ 署名 aaaa... を「DigiCert 中間CA の公開鍵」で復号    │
│     → ハッシュ値A                                   │
│                                                     │
│ サーバー証明書の内容を自分でハッシュ化               │
│     → ハッシュ値B                                   │
│                                                     │
│ A == B ? → 一致！                                   │
│ → この証明書は DigiCert 中間CA が発行した本物だ！    │
└─────────────────────────────────────────────────────┘
```

#### Step 3: 中間証明書を検証

**「中間証明書」が本物か確認する。**（同じことを繰り返す）

```
中間証明書を見る
    ↓
「発行者: DigiCert ルートCA」と書いてある
    ↓
DigiCert ルートCA の公開鍵を使って署名を検証する
```

**署名の検証:**

```
┌─────────────────────────────────────────────────────┐
│ 署名 bbbb... を「DigiCert ルートCA の公開鍵」で復号  │
│     → ハッシュ値A                                   │
│                                                     │
│ 中間証明書の内容を自分でハッシュ化                   │
│     → ハッシュ値B                                   │
│                                                     │
│ A == B ? → 一致！                                   │
│ → この中間証明書は DigiCert ルートCA が発行した本物！ │
└─────────────────────────────────────────────────────┘
```

#### Step 4: ルート証明書を確認

**「DigiCert ルートCA」は信頼できるか？**

```
DigiCert ルートCA の証明書
    ↓
ブラウザに最初から入ってる？
    ↓
YES → 信頼できる CA だ！
    ↓
全部 OK → amazon.co.jp は本物！
```

#### まとめ: チェーンの検証

```mermaid
flowchart TB
    subgraph Step1["Step 1: 証明書を受け取る"]
        Cert1["サーバー証明書"]
        Cert2["中間証明書"]
    end

    subgraph Step2["Step 2: サーバー証明書を検証"]
        V1["中間CA の公開鍵で署名を検証"]
        V1 --> R1["ハッシュ値が一致 → OK"]
    end

    subgraph Step3["Step 3: 中間証明書を検証"]
        V2["ルートCA の公開鍵で署名を検証"]
        V2 --> R2["ハッシュ値が一致 → OK"]
    end

    subgraph Step4["Step 4: ルート証明書を確認"]
        V3["ブラウザに入ってる？"]
        V3 --> R3["YES → 信頼できる！"]
    end

    Step1 --> Step2 --> Step3 --> Step4
```

**ポイント:**
- 各証明書の署名を、その発行者の公開鍵で検証する
- 検証 = 「署名から取り出したハッシュ値」と「自分で計算したハッシュ値」を比較
- 最終的にブラウザに入っているルートCAまでたどり着けばOK

#### 検証が失敗するケース

| ケース | 何が起きる |
|--------|-----------|
| ハッシュ値が一致しない | 証明書が改ざんされている |
| 発行者の証明書がない | チェーンが途切れている |
| ルートCAがブラウザにない | 信頼できないCA（自己署名証明書など） |
| 有効期限切れ | 証明書が古い |
| ドメインが違う | 別サイトの証明書 |

→ いずれの場合も「この接続ではプライバシーが保護されません」と警告が出る

### 証明書の種類

| 種類                              | 検証レベル           | 用途             |
| --------------------------------- | -------------------- | ---------------- |
| **DV（Domain Validation）**       | ドメイン所有のみ確認 | 一般サイト、個人 |
| **OV（Organization Validation）** | 組織の実在確認       | 企業サイト       |
| **EV（Extended Validation）**     | 厳格な審査           | 銀行、EC サイト  |

---

## HTTPS 通信の流れ

実際に HTTPS で通信する時の流れ（TLS ハンドシェイク）。

```mermaid
sequenceDiagram
    participant C as クライアント
    participant S as サーバー

    Note over C,S: TLS ハンドシェイク
    C->>S: ClientHello（対応する暗号方式のリスト）
    S->>C: ServerHello + Certificate（証明書）

    Note over C: 証明書を検証 → 共通鍵を生成

    C->>S: ClientKeyExchange（暗号化した共通鍵）
    C->>S: Finished
    S->>C: Finished

    Note over C,S: 暗号化通信開始
    C->>S: 暗号化されたリクエスト
    S->>C: 暗号化されたレスポンス
```

**ポイント:**

1. 証明書で「本物のサーバーか」を確認
2. 公開鍵暗号で「共通鍵」を安全に交換
3. 以降は高速な共通鍵暗号で通信

---

## HTTPS の導入方法

### 方法 1: 自分で管理（Let's Encrypt）

```bash
# 1. certbot をインストール
sudo apt install certbot

# 2. 証明書を取得
sudo certbot certonly --standalone -d example.com

# 3. nginx に設定
# /etc/nginx/sites-available/default
server {
    listen 443 ssl;
    ssl_certificate /etc/letsencrypt/live/example.com/fullchain.pem;
    ssl_certificate_key /etc/letsencrypt/live/example.com/privkey.pem;
}
```

**注意:** Let's Encrypt は 90 日で期限切れ。自動更新の設定が必要。

### 方法 2: AWS ACM + ALB（推奨）

ACM（AWS Certificate Manager）を使うと、証明書の発行・管理が自動化される。

```mermaid
flowchart LR
    A["1. ACM で<br/>証明書リクエスト"] --> B["2. DNS レコード<br/>を追加"] --> C["3. ALB に<br/>証明書を適用"]
```

**ACM のメリット:**

| メリット     | 説明                           |
| ------------ | ------------------------------ |
| **無料**     | AWS サービスで使う分には無料   |
| **自動更新** | 有効期限が切れる前に自動で更新 |
| **簡単**     | 数クリックで発行               |

### SSL 終端

```mermaid
flowchart LR
    User["ユーザー"] ==>|HTTPS<br/>暗号化| ALB["ALB<br/>（証明書はここ）"]
    ALB -->|HTTP<br/>平文| ECS["ECS"]

    style ALB fill:#ff9800
```

ALB が HTTPS を処理する（SSL 終端）ので、ECS は HTTP のままで OK。

**Q: VPC 内が平文で大丈夫？**
→ VPC 内はインターネットから隔離されているので安全。

### 比較

| 項目           | 自分で管理（Let's Encrypt） | AWS（ACM + ALB） |
| -------------- | --------------------------- | ---------------- |
| 証明書の取得   | certbot で取得              | コンソールで設定 |
| サーバーへ設置 | 手動で配置・設定            | 不要             |
| 有効期限の更新 | 自動更新設定が必要          | 完全自動         |
| コスト         | 無料                        | 無料             |
| 複雑さ         | やや複雑                    | 簡単             |

**結論:** AWS を使うなら ACM + ALB が楽。

---

## まとめ

| 項目               | ポイント                                   |
| ------------------ | ------------------------------------------ |
| **HTTP**           | ブラウザとサーバーの通信プロトコル         |
| **HTTPS**          | HTTP + 暗号化                              |
| **暗号化**         | 公開鍵暗号で鍵交換、共通鍵暗号でデータ通信 |
| **SSL 証明書**     | サーバーの身元証明 + 公開鍵の配布          |
| **認証局（CA）**   | 証明書を発行する信頼された第三者           |
| **証明書チェーン** | ルート → 中間 → サーバー証明書の信頼の連鎖 |
| **ACM**            | AWS の無料証明書サービス、自動更新対応     |

---

## 確認問題

### 問 1

> HTTPS を使うと何が保護される？

<details>
<summary>答え</summary>

1. **盗聴防止**: 通信内容が暗号化され、第三者に見られない
2. **改ざん防止**: データが途中で書き換えられていないことを保証
3. **なりすまし防止**: 証明書で相手が本物か確認できる

</details>

### 問 2

> SSL 証明書はなぜ必要？暗号化だけじゃダメ？

<details>
<summary>答え</summary>

暗号化だけでは「通信相手が本物か」を確認できない。

証明書がないと、攻撃者が偽サイトを作って暗号化通信しても、ユーザーは本物と区別できない（中間者攻撃）。

</details>

### 問 3

> 「この接続ではプライバシーが保護されません」というエラーが出る原因は？

<details>
<summary>答え</summary>

- 証明書の有効期限が切れている
- 証明書のドメインが違う
- 認証局がブラウザに信頼されていない（自己署名証明書など）
- 証明書チェーンが不完全（中間証明書がない）

</details>

### 問 4

> SSL 終端とは？なぜ ALB で行う？

<details>
<summary>答え</summary>

**SSL 終端**: HTTPS の暗号化/復号化を ALB で行い、ALB より後ろは HTTP で通信すること。

**ALB で行う理由:**

- サーバーの負荷軽減（暗号化処理は重い）
- 証明書管理の一元化（サーバー 10 台でも証明書は 1 つ）
- VPC 内は安全なので平文でも問題ない

</details>

---

[← 目次に戻る](./02-aws.md)
